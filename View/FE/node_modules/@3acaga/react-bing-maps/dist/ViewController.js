import React, { useContext, useEffect, useRef } from "react";
import { MapContext } from "./ReactBingMap";
var clearQ = function (q) {
    q.forEach(clearTimeout);
    q.splice(0, q.length);
};
var ViewController = function (_a) {
    var _b = _a.center, center = _b === void 0 ? new window.Microsoft.Maps.Location(0, 0) : _b, _c = _a.zoom, zoom = _c === void 0 ? 2 : _c, children = _a.children;
    var map = useContext(MapContext);
    var animationQueue = useRef([]).current;
    var prevZoomRef = useRef(zoom);
    useEffect(function () {
        var prevZoom = prevZoomRef.current;
        prevZoomRef.current = zoom;
        var _a = map.getCenter(), latOld = _a.latitude, lngOld = _a.longitude;
        var latNew = center.latitude, lngNew = center.longitude;
        if (Math.abs(zoom - prevZoom) < 1 - 1e-6 &&
            (latNew === latOld && lngNew === lngOld)) {
            return;
        }
        clearQ(animationQueue);
        if ((Math.abs(zoom - prevZoom) >= 1e-6 &&
            (latNew === latOld && lngNew === lngOld)) ||
            Math.abs(zoom - prevZoom) < 1e-6) {
            map.setView({
                zoom: zoom,
                center: center,
                // @ts-ignore-next-line
                animate: true
            });
            return;
        }
        var iterCount = Math.abs(prevZoom - zoom) >= 1
            ? Math.floor(Math.abs(prevZoom - zoom))
            : 1;
        var dt = 100; // ms
        var dZoom = (zoom - prevZoom) / iterCount;
        var dLat = (latNew - latOld) / iterCount;
        var dLng = (lngNew - lngOld) / iterCount;
        var _loop_1 = function (i) {
            var timeout = setTimeout(function () {
                map.setView({
                    center: new window.Microsoft.Maps.Location(latOld + dLat * i, lngOld + dLng * i),
                    zoom: prevZoom + dZoom * i,
                    // @ts-ignore-next-line
                    animate: true
                });
                animationQueue.splice(animationQueue.findIndex(function (to) { return to === timeout; }), 1);
            }, dt * (i - 1));
            animationQueue.push(timeout);
        };
        for (var i = 1; i <= iterCount; i++) {
            _loop_1(i);
        }
        var vcc = window.Microsoft.Maps.Events.addHandler(map, "viewchange", function (e) {
            if (e.cause !== 0) {
                clearQ(animationQueue);
                window.Microsoft.Maps.Events.removeHandler(vcc);
            }
        });
        setTimeout(function () {
            window.Microsoft.Maps.Events.removeHandler(vcc);
        }, dt * iterCount);
    }, [zoom, center.latitude, center.longitude]);
    return React.createElement(React.Fragment, null, children);
};
export default React.memo(ViewController);
