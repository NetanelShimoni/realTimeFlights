var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { create } from "d3-selection";
import { curveCatmullRom, line } from "d3-shape";
import { range } from "d3-array";
export function generatePathPoints(curvePoints, curved, pathPointsCount) {
    var _svg = create("svg");
    var _path = _svg.append("path");
    var lineGenerator = line()
        .x(function (d) { return d.latitude; })
        .y(function (d) { return d.longitude; });
    if (curved) {
        lineGenerator = lineGenerator.curve(curveCatmullRom.alpha(0.75));
        if (curvePoints.length === 2) {
            var _a = __read(curvePoints, 2), _b = _a[0], y1 = _b.latitude, x1 = _b.longitude, _c = _a[1], y2 = _c.latitude, x2 = _c.longitude;
            // add middle point
            var a = (y2 - y1) / (x2 - x1);
            var ax = Math.tan(Math.atan(a) + Math.PI / 2);
            var c = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            var dx = c / (7 * (ax - a));
            var dy = ax * dx;
            var xl = x2 - x1;
            var yl = y2 - y1;
            curvePoints.splice(1, 0, {
                latitude: y1 + yl / 3 + dy,
                longitude: x1 + xl / 3 + dx
            }, {
                latitude: y1 + (2 * yl) / 3 + dy,
                longitude: x1 + (2 * xl) / 3 + dx
            });
        }
    }
    _path.attr("d", lineGenerator(curvePoints));
    var svgLine = _path.node();
    var lineLength = svgLine.getTotalLength();
    var numPoints = pathPointsCount
        ? pathPointsCount
        : curved
            ? Math.ceil(lineLength * 2.5) < 15
                ? 15
                : Math.ceil(lineLength * 2.5)
            : 2;
    var interval = lineLength / (numPoints - 1);
    if (numPoints === 1) {
        interval = 0;
    }
    else {
        interval = lineLength / (numPoints - 1);
    }
    return {
        path: range(numPoints).map(function (d) {
            var _a = svgLine.getPointAtLength(d * interval), x = _a.x, y = _a.y;
            return new window.Microsoft.Maps.Location(x, y);
        }),
        length: lineLength
    };
}
